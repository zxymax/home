webpackJsonp([0],{"1uuo":function(t,e){},"20ed":function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var s={render:function(){var t=this.$createElement;return(this._self._c||t)("div",[this._v("CreateMeetup")])},staticRenderFns:[]},a=n("VU/8")(null,s,!1,null,null,null);e.default=a.exports},"5vyG":function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var s={render:function(){var t=this.$createElement;return(this._self._c||t)("div",[this._v("meetups")])},staticRenderFns:[]},a=n("VU/8")(null,s,!1,null,null,null);e.default=a.exports},"7Kd+":function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var s={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("v-layout",{attrs:{row:"",wrap:""}},[n("v-flex",{attrs:{xs12:""}},[n("v-card",[n("v-toolbar",{attrs:{color:"pink",dark:""}},[n("v-toolbar-title",[t._v("JavaScript This 的六道坎")]),t._v(" "),n("v-spacer")],1)],1)],1),t._v(" "),t._l(t.codeDatas,function(e,s){return n("v-flex",{key:s,attrs:{xs12:"","pa-1":""}},[n("v-card",{staticClass:"white--text",attrs:{color:"blue-grey darken-2"}},[n("v-container",{attrs:{fluid:"","grid-list-lg":""}},[n("v-layout",{attrs:{row:""}},[n("v-flex",[n("div",[n("div",{staticClass:"headline"},[t._v(t._s(e.title))]),t._v(" "),n("div",[t._v(" "+t._s(e.subtitle))]),t._v(" "),e.code?n("div",[n("codemirror",{attrs:{value:e.code}})],1):t._e(),t._v(" "),e.characteristic?n("div",[e.characteristic.advantage?n("v-list",{attrs:{"two-line":"",subheader:""}},[n("v-subheader",{staticClass:"teal--text"},[t._v("优点")]),t._v(" "),n("v-card",[n("v-card-text",{staticClass:"pl-5"},t._l(e.characteristic.advantage,function(e,s){return n("p",{staticClass:"text-sm-left"},[t._v(t._s(e))])}))],1)],1):t._e(),t._v(" "),n("v-divider"),t._v(" "),e.characteristic.defect?n("v-list",{attrs:{"two-line":"",subheader:""}},[n("v-subheader",{staticClass:"red--text"},[t._v("缺点")]),t._v(" "),n("v-card-text",{staticClass:"pl-5"},t._l(e.characteristic.defect,function(e,s){return n("p",{staticClass:"text-sm-left"},[t._v(t._s(e))])}))],1):t._e()],1):t._e()])])],1)],1)],1)],1)})],2)},staticRenderFns:[]},a=n("VU/8")({data:function(){return{codeDatas:[{title:"第一层：世界尽头",subtitle:"权力最小的大佬是作为备胎的存在，在普通情况下就是全局，浏览器里就是window；在use strict的情况下就是undefined。",code:"function showThis() {\n                console.log(this)\n              }\n              function showStrictThis() {\n                'use strict'\n                console.log(this)\n              }\n              showThis()  // window\n              showStrictThis() // undefined"},{title:"第二层：点石成金",subtitle:"如果用到this的那个函数是属于某个 context object 的，那么这个 context object 绑定到this。比如下面的例子，boss是returnThis的 context object ，或者说returnThis属于boss。",code:"let boss = {\n              name: 'boss',\n              returnThis() {\n                return this\n              }\n            }\n             console.log(boss.returnThis() === boss) // true\n             \n             "},{title:"再往下看",subtitle:"在boss2.returnThis里，使用this的函数是boss1.returnThis，所以this绑定到boss1； 在boss3.returnThis里，使用this的函数是returnThis，所以this绑定到备胎。",code:"let boss = {\n              name: 'boss',\n              returnThis() {\n                return this\n              }\n            }\n             console.log(boss.returnThis() === boss) // true\n             //============================================\n             //再往下看\n             let boss1 = {\n              name: 'boss1',\n              returnThis () {\n                return this\n              }\n            }\n            let boss2 = {\n              name: 'boss2',\n              returnThis() {\n                return boss1.returnThis()\n              }\n            }\n            let boss3 = {\n              name: 'boss3',\n              returnThis() {\n                let returnThis = boss1.returnThis\n                return returnThis()\n              }\n            }\n            boss1.returnThis() // boss1\n            boss2.returnThis() // boss1\n            boss3.returnThis() // window"},{title:"要想把this绑定到boss2怎么做呢？",subtitle:"没错，只要让使用this的函数是属于boss2就行。",code:"\n            let boss1 = {\n              name: 'boss1',\n              returnThis() {\n                console.log(this)\n              }\n            }\n            let boss2 = {\n              name: 'boss2',\n              returnThis: boss1.returnThis\n            }\n            boss2.returnThis() // boss2\n          "},{title:"第三层：指腹为婚",subtitle:"第三层大佬是Object.prototype.call和Object.prototype.apply，它们可以通过参数指定this。（注意this是不可以直接赋值的哦，this = 2会报ReferenceError。）",code:"function returnThis() {\n              return this\n            }\n            let boss1 = {\n              name: 'boss1'\n            }\n            returnThis() // window\n            returnThis.call(boss1) // boss1\n            returnThis.apply(boss1) // boss1\n          "},{title:"第四层：海誓山盟",subtitle:"第四层大佬是Object.prototype.bind，他不但通过一个新函数来提供永久的绑定，还会覆盖第三层大佬的命令。",code:"function returnThis() {\n              return this\n            }\n            let boss1 = {\n              name: 'boss1'\n            }\n            let boss1ReturnThis = returnThis.bind(boss1)\n            boss1ReturnThis() // boss1\n\n            let boss2 = {\n              name: 'boss2'\n            }\n            boss1ReturnThis.call(boss2) // boss1"},{title:"第五层：内有乾坤",subtitle:"一个比较容易忽略的会绑定this的地方就是new。当我们new一个函数时，就会自动把this绑定在新对象上，然后再调用这个函数。它会覆盖bind的绑定。",code:"function showThis() {\n                return this\n              }\n              showThis() // window\n              new showThis() // showThis\n              let boss1 = {\n                name: 'boss1'\n              }\n              showThis.call(boss1) // boss1\n              new showThis().call(boss1) // 报错TypeError\n              let boss1ShowThis = showThis.bind(boss1)\n              boss1ShowThis() // boss1\n              new boss1ShowThis() // boss1ShowThis"},{title:"第六层：军令如山",subtitle:"最后一个法力无边的大佬就是 ES2015 的箭头函数。箭头函数里的this不再妖艳，被永远封印到当前词法作用域之中，称作 Lexical this ，在代码运行前就可以确定。没有其他大佬可以覆盖。这样的好处就是方便让回调函数的this使用当前的作用域，不怕引起混淆。所以对于箭头函数，只要看它在哪里创建的就行。如果对 V8 实现的词法作用域感兴趣可以看看这里。",code:"function callback(cb) {\n                    cb()\n                  }\n                  callback(()=>{ console.log(this) })  // window\n                  let boss1 = {\n                    name: 'boss1',\n                    callback: callback,\n                    callback2(){\n                      (()=>{\n                        console.log(this)\n                      })\n                    }\n                  }\n                  boss1.callback(()=>{ console.log(this) }) // window\n                  boss1.callback2(()=>{ console.log(this) }) // boss1"},{title:"下面这种奇葩的使用方式就需要注意：",subtitle:"如果你不知道最后为什么会是 boss2，继续理解“对于箭头函数，只要看它在哪里创建”这句话。",code:"let returnThis = () => this\n              returnThis() // window\n              new returnThis() //TypeError\n\n              let boss1 = {\n                name: 'boss1',\n                returnThis() {\n                  let func = () => this\n                  return func()\n                }\n              }\n              returnThis.call(boss1) // window\n\n              let boss1ReturnThis = returnThis.bind(boss1)\n                boss1ReturnThis() // window\n                boss1.returnThis() // boss1\n\n              let boss2 = {\n                name: 'boss2',\n                returnThis: boss1.returnThis\n              }\n              boss2.returnThis() // boss2\n        "}]}}},s,!1,null,null,null);e.default=a.exports},BbIT:function(t,e){},GAZi:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var s={render:function(){var t=this.$createElement,e=this._self._c||t;return e("v-container",[e("v-layout",{attrs:{row:"",wrap:""}},[e("v-flex",{staticClass:"text-xs-center",attrs:{xs12:""}},[e("v-btn",{staticClass:"info",attrs:{large:""}},[this._v("\n\t\t\t\tExplore Meetups\n\t\t\t")]),this._v(" "),e("v-btn",{staticClass:"info",attrs:{large:""}},[this._v("\n\t\t\t\tOrganize Meetup\n\t\t\t")])],1)],1),this._v(" "),e("v-layout",{attrs:{row:"",wrap:""}},[e("v-flex",{attrs:{xs12:""}},[e("v-carousel",this._l(this.items,function(t,n){return e("v-carousel-item",{key:n,attrs:{src:t.imageUrl}})}))],1)],1)],1)},staticRenderFns:[]},a=n("VU/8")({data:function(){return{items:[{imageUrl:"http://c.hiphotos.baidu.com/image/h%3D300/sign=e3b76ad36081800a71e58f0e813433d6/d50735fae6cd7b89acbea9df032442a7d8330e9f.jpg",id:"adfdjflfsse1",title:"我是来自星星的你"},{imageUrl:"http://c.hiphotos.baidu.com/image/h%3D300/sign=9f9323341c38534393cf8121a312b01f/e1fe9925bc315c609e11bbb781b1cb13485477e6.jpg",id:"dbaj3q2112313",title:"我喜欢的事情我也不知道"}]}}},s,!1,null,null,null);e.default=a.exports},bsW1:function(t,e){},eowj:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var s={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("v-layout",{attrs:{row:"",wrap:""}},[n("v-flex",{attrs:{xs12:""}},[n("v-card",[n("v-toolbar",{attrs:{color:"pink",dark:""}},[n("v-toolbar-title",[t._v("Vuex学习心得")]),t._v(" "),n("v-spacer")],1)],1)],1),t._v(" "),n("v-flex",{attrs:{xs12:""}},[n("v-alert",{attrs:{type:"info",value:!0}},[t._v("\n\t      Vuex概念： Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\t    ")])],1),t._v(" "),n("v-flex",{attrs:{xs12:"","offset-xs1":""}},[n("v-card",[n("v-toolbar",{attrs:{color:"teal",dark:""}},[n("v-toolbar-title",{staticClass:"text-xs-center"},[t._v("什么是状态管理模式？")])],1),t._v(" "),n("v-list",{attrs:{subheader:""}},t._l(t.items,function(e,s){return n("v-list-tile",{key:e.title,attrs:{avatar:""},on:{click:function(t){}}},[n("v-list-tile-content",{staticClass:"pl-4"},[n("v-list-tile-title",[t._v(t._s(s+1)+". "+t._s(e.title))])],1)],1)})),t._v(" "),n("v-divider"),t._v(" "),n("v-subheader",[t._v("以下是一个表示 “单向数据流“理念的极简示意图")])],1)],1),t._v(" "),n("v-flex",{staticClass:"mt-1",attrs:{xs12:"",sm6:"","offset-xs1":""}},[n("v-card",[n("v-card-media",{attrs:{src:"https://vuex.vuejs.org/zh-cn/images/flow.png",height:"400px"}})],1)],1),t._v(" "),n("v-flex",{staticClass:"mt-1",attrs:{xs12:"","offset-xs1":""}},[n("v-alert",{attrs:{type:"warning",value:!0}},[t._v("\n\t\t      注意： 但是，当我们的应用遇到多个组件共享状态时,单项数据流的简洁性很容易破坏：\n\t\t    ")]),t._v(" "),n("v-list",{attrs:{subheader:""}},[n("v-list-tile",{attrs:{avatar:""},on:{click:function(t){}}},[n("v-list-tile-content",{staticClass:"pl-4"},[n("v-list-tile-title",[t._v("问题1:多个视图依赖于同一状态。")])],1)],1),t._v(" "),n("v-list-tile",{attrs:{avatar:""},on:{click:function(t){}}},[n("v-list-tile-content",{staticClass:"pl-4"},[n("v-list-tile-title",[t._v(" 问题2:来自不同视图的行为需要变更同一状态。")])],1)],1)],1),t._v(" "),n("v-alert",{attrs:{type:"info",value:!0}},[t._v("\n\t     因此我们需要把组件的共享状态抽取出来，以一个全局单例模式管理，在这种模式下，我们组件树构成了一个巨大的”视图“，不管在树的哪个位置，任何组件都能获取状态或者触发行为！\n\t    ")]),t._v(" "),n("v-alert",{attrs:{type:"info",value:!0}},[t._v("\n\t    通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux、和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。\n\t  ")]),t._v(" "),n("v-card",[n("v-card-media",{attrs:{src:"https://vuex.vuejs.org/zh-cn/images/vuex.png",height:"700px"}})],1),t._v(" "),n("v-toolbar",{attrs:{color:"teal",dark:""}},[n("v-toolbar-title",{staticClass:"text-xs-center"},[t._v("什么情况下我应该使用 Vuex？")])],1),t._v(" "),n("v-alert",{attrs:{type:"success",value:!0}},[t._v("\n        如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus 就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。\n      ")]),t._v(" "),n("v-toolbar",{attrs:{color:"teal",dark:""}},[n("v-toolbar-title",{staticClass:"text-xs-center"},[t._v("安装Vuex")])],1),t._v(" "),n("v-list",{attrs:{"two-line":""}},[[n("v-subheader",[n("code",{staticClass:"mr-2"},[t._v("npm install vuex --save ")]),t._v(" "),n("code",[t._v("yarn add vuex")])])],t._v(" "),n("v-alert",{attrs:{type:"info",value:!0}},[t._v("在store/index.js文件中引用vuex文件 并且使用use使用vuex")]),t._v(" "),[n("v-subheader",[n("code",{staticClass:"mr-2"},[t._v("import Vue from 'vue'")]),t._v(" "),n("code",{staticClass:"mr-2"},[t._v("import Vuex from 'vuex'")]),t._v(" "),n("code",[t._v("Vue.use(Vuex)")])])]],2),t._v(" "),n("v-toolbar",{attrs:{color:"teal",dark:""}},[n("v-toolbar-title",{staticClass:"text-xs-center"},[t._v("Vuex核心概念")])],1),t._v(" "),n("v-list",[n("v-list-tile",[n("v-btn",{attrs:{color:"info"}},[t._v("State")]),t._v(" "),n("v-btn",{attrs:{color:"info"}},[t._v("Getter")]),t._v(" "),n("v-btn",{attrs:{color:"info"}},[t._v("Mutation")]),t._v(" "),n("v-btn",{attrs:{color:"info"}},[t._v("Action")]),t._v(" "),n("v-btn",{attrs:{color:"info"}},[t._v("Module")])],1)],1)],1),t._v(" "),n("v-container",{attrs:{fluid:"","grid-list-sm":"","offset-sm-1":""}},[n("v-layout",{attrs:{row:"",wrap:""}},t._l(t.codeDatas,function(e,s){return n("v-flex",{key:s,attrs:{"d-flex":"",xs12:""}},[n("v-layout",{attrs:{column:""}},[n("v-flex",{attrs:{"d-flex":""}},[n("v-card",{attrs:{color:"blue-grey",dark:"",tile:"",flat:""}},[n("v-card-text",[n("v-alert",{attrs:{type:"info",value:!0}},[n("v-btn",{attrs:{color:"indigo"}},[t._v(t._s(e.word))]),t._v(t._s(e.title)+"\n    \t \t\t\t\t")],1),t._v(" "),t._l(e.codes,function(s,a){return n("div",[n("p",[t._v(t._s(s.subtitle))]),t._v(" "),s.code?n("codemirror",{attrs:{value:s.code}}):t._e(),t._v(" "),e.supplement?n("v-alert",{attrs:{type:"warning",value:!0}},[t._v("\n    \t \t\t\t\t\t\t"+t._s(e.supplement)+"\n    \t \t\t\t\t")]):t._e()],1)}),t._v(" "),t._l(e.subWord,function(e,s){return n("div",{key:s},[n("v-alert",{attrs:{type:"info",value:!0}},[e.title?n("v-btn",{attrs:{color:"indigo"}},[t._v(t._s(e.title))]):t._e(),t._v(t._s(e.subtitle)+"\n    \t \t\t\t\t")],1),t._v(" "),e.subcode?n("codemirror",{attrs:{value:e.subcode}}):t._e(),t._v(" "),e.supplement?n("v-alert",{attrs:{type:"warning",value:!0}},[t._v("\n    \t \t\t\t\t\t\t"+t._s(e.supplement)+"\n    \t \t\t\t\t")]):t._e()],1)})],2)],1)],1)],1)],1)}))],1),t._v(" "),n("v-flex",{attrs:{xs12:""}},[n("v-card",[n("v-toolbar",{attrs:{color:"teal",dark:""}},[n("v-toolbar-title",{staticClass:"text-xs-center"},[t._v("项目结构")])],1),t._v(" "),n("v-list",{attrs:{subheader:""}},t._l(t.vuexRules,function(e,s){return n("v-list-tile",{key:e.title,attrs:{avatar:""},on:{click:function(t){}}},[n("v-list-tile-content",{staticClass:"pl-4"},[n("v-list-tile-title",[t._v(t._s(s+1)+". "+t._s(e.title))])],1)],1)})),t._v(" "),n("v-divider")],1),t._v(" "),n("v-card",{attrs:{color:"blue-grey",dark:"",tile:"",flat:""}},[n("v-card-text",[n("v-alert",{attrs:{type:"info",value:!0}},[t._v("\n\n    \t \t\t\t\t\t只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。\n    \t \t\t\t\t")]),t._v(" "),n("v-alert",{attrs:{type:"warning",value:!0}},[t._v("\n    \t \t\t\t\t对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：\n    \t \t\t\t")]),t._v(" "),n("codemirror",{attrs:{value:t.ruleCode}})],1)],1)],1),t._v(" "),n("v-flex",{attrs:{xs12:""}},[n("v-card",[n("v-toolbar",{attrs:{color:"teal",dark:""}},[n("v-toolbar-title",{staticClass:"text-xs-center"},[t._v("路由懒加载")])],1),t._v(" "),n("v-card-text",[n("v-alert",{attrs:{type:"info",value:!0}},[t._v("\n\n    \t \t\t\t\t\t当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。\n    \t \t\t\t\t")]),t._v(" "),n("v-alert",{attrs:{type:"warning",value:!0}},[t._v("\n    \t \t\t\t\t结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。\n    \t \t\t\t")]),t._v(" "),n("codemirror",{attrs:{value:"const Foo = () => Promise.resolve({ /* 组件定义对象 */ })"}}),t._v(" "),n("v-alert",{attrs:{type:"info",value:!0}},[t._v("\n      \t\t\t\t\t\t\t第二，在 Webpack 2 中，我们可以使用动态 import语法来定义代码分块点 (split point)：\n      \t\t\t\t\t")]),t._v(" "),n("codemirror",{attrs:{value:"import('./Foo.vue') // 返回 Promise"}}),t._v(" "),n("v-alert",{attrs:{type:"warning",value:!0}},[t._v("\n    \t \t\t\t\t注意：如果您使用的是 Babel，你将需要添加 syntax-dynamic-import 插件，才能使 Babel 可以正确地解析语法。合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。\n    \t \t\t\t")]),t._v(" "),n("v-alert",{attrs:{type:"info",value:!0}},[t._v("\n    \t \t\t\t\t结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件。\n    \t \t\t\t")]),t._v(" "),n("codemirror",{attrs:{value:"const Foo = () => import('./Foo.vue')"}}),t._v(" "),n("v-alert",{attrs:{type:"info",value:!0}},[t._v("\n    \t \t\t\t\t在路由配置中什么都不需要改变，只需要像往常一样使用 Foo：\n    \t \t\t\t")]),t._v(" "),n("codemirror",{attrs:{value:"const router = new VueRouter({\n\t\t\t\t  routes: [\n\t\t\t\t    { path: '/foo', component: Foo }\n\t\t\t\t  ]\n\t\t\t\t})"}})],1)],1)],1),t._v(" "),n("v-flex",{attrs:{xs12:""}},[n("v-card",[n("v-toolbar",{attrs:{color:"teal",dark:""}},[n("v-toolbar-title",{staticClass:"text-xs-center"},[t._v("把组件按组分块")])],1),t._v(" "),n("v-card-text",[n("v-alert",{attrs:{type:"info",value:!0}},[t._v("\n\n    \t \t\t\t\t\t有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用 命名 chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack > 2.4)。\n    \t \t\t\t\t")]),t._v(" "),n("codemirror",{attrs:{value:"const Foo = () => import(/* webpackChunkName: 'group-foo' */ './Foo.vue')\n\t\t\t\tconst Bar = () => import(/* webpackChunkName: 'group-foo' */ './Bar.vue')\n\t\t\t\tconst Baz = () => import(/* webpackChunkName: 'group-foo' */ './Baz.vue')\n\t\t\t"}}),t._v(" "),n("v-alert",{attrs:{type:"warning",value:!0}},[t._v("\n    \t \t\t\t\tWebpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中。\n    \t \t\t\t")])],1)],1)],1)],1)},staticRenderFns:[]},a=n("VU/8")({data:function(){return{items:[{active:!0,title:"state,驱动应用的数据源"},{active:!0,title:"view,以声明方式将state映射到视图"},{title:"actions,响应式在view上的用户输入导致的状态变化"}],vuexRules:[{active:!0,title:"应用层级的状态应该集中到单个 store 对象中。"},{active:!0,title:"提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。"},{title:"异步逻辑都应该封装到 action 里面。"}],ruleCode:"\n\t\t\t\t├── index.html\n\t\t\t\t├── main.js\n\t\t\t\t├── api\n\t\t\t\t│   └── ... # 抽取出API请求\n\t\t\t\t├── components\n\t\t\t\t│   ├── App.vue\n\t\t\t\t│   └── ...\n\t\t\t\t└── store\n\t\t\t\t    ├── index.js          # 我们组装模块并导出 store 的地方\n\t\t\t\t    ├── actions.js        # 根级别的 action\n\t\t\t\t    ├── mutations.js      # 根级别的 mutation\n\t\t\t\t    └── modules\n\t\t\t\t        ├── cart.js       # 购物车模块\n\t\t\t\t        └── products.js   # 产品模块\n\t\t\t\t\t",codeDatas:[{word:"State",title:"单一状态树，即Vuex中的基本数据。用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。\n",codes:[{subtitle:"我们可以通过Vue的computed获得Vuex的state，如下：",code:"const store = new Vuex.Store({\n\t\t\t\t\t\t\t\t\t\t    state: {\n\t\t\t\t\t\t\t\t\t\t        count:0\n\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\tconst app = new Vue({\n\t\t\t\t\t\t\t\t\t\t    //..\n\t\t\t\t\t\t\t\t\t\t    store,\n\t\t\t\t\t\t\t\t\t\t    computed: {\n\t\t\t\t\t\t\t\t\t\t        count: function(){\n\t\t\t\t\t\t\t\t\t\t            return this.$store.state.count\n\t\t\t\t\t\t\t\t\t\t        }\n\t\t\t\t\t\t\t\t\t\t    },\n\t\t\t\t\t\t\t\t\t\t    //..\n\t\t\t\t\t\t\t\t\t\t})"}],subWord:[{title:"mapState辅助函数",subtitle:"当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键。",subcode:"// 在单独构建的版本中辅助函数为 Vuex.mapState\n\t\t\t\t\timport { mapState } from 'vuex'\n\n\t\t\t\t\texport default {\n\t\t\t\t\t  // ...\n\t\t\t\t\t  computed: mapState({\n\t\t\t\t\t    // 箭头函数可使代码更简练\n\t\t\t\t\t    count: state => state.count,\n\n\t\t\t\t\t    // 传字符串参数 'count' 等同于 'state => state.count'\n\t\t\t\t\t    countAlias: 'count',\n\n\t\t\t\t\t    // 为了能够使用 'this' 获取局部状态，必须使用常规函数\n\t\t\t\t\t    countPlusLocalState (state) {\n\t\t\t\t\t      return state.count + this.localCount\n\t\t\t\t\t    }\n\t\t\t\t\t  })\n\t\t\t\t\t}\n\t\t\t\t"}],supplement:"每当 store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。"},{word:"Getters",title:"即从store的state中派生出的状态。",codes:[{subtitle:"getters接收state作为其第一个参数，接受其他 getters 作为第二个参数，如不需要，第二个参数可以省略如下例子：",code:"const store = new Vuex.Store({\n\t\t\t\t\t\t\t    state: {\n\t\t\t\t\t\t\t        count:0\n\t\t\t\t\t\t\t    }，\n\t\t\t\t\t\t\t    getters: {\n\t\t\t\t\t\t\t        // 单个参数\n\t\t\t\t\t\t\t        countDouble: function(state){\n\t\t\t\t\t\t\t            return state.count * 2\n\t\t\t\t\t\t\t        },\n\t\t\t\t\t\t\t        // 两个参数\n\t\t\t\t\t\t\t        countDoubleAndDouble: function(state, getters) {\n\t\t\t\t\t\t\t            return getters.countDouble * 2\n\t\t\t\t\t\t\t        }\n\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t"},{subtitle:"与state一样，我们也可以通过Vue的Computed获得Vuex的getters。",code:"const app = new Vue({\n\t\t\t\t\t    //..\n\t\t\t\t\t    store,\n\t\t\t\t\t    computed: {\n\t\t\t\t\t        count: function(){\n\t\t\t\t\t            return this.$store.state.count\n\t\t\t\t\t        },\n\t\t\t\t\t        countDouble: function(){\n\t\t\t\t\t            return this.$store.getters.countDouble\n\t\t\t\t\t        },\n\t\t\t\t\t        countDoubleAndDouble: function(){\n\t\t\t\t\t            return this.$store.getters.countDoubleAndDouble\n\t\t\t\t\t        }\n\t\t\t\t\t    },\n\t\t\t\t\t    //..\n\t\t\t\t\t})"}],subWord:[{title:"mapGetters 辅助函数",subtitle:"mapGetters 辅助函数仅仅是将 store 中的 getters 映射到局部计算属性，与state类似",subcode:"import { mapGetters } from 'vuex'\n\t\t\t\t\t\t\t\t\texport default {\n\t\t\t\t\t\t\t\t\t  // ...\n\t\t\t\t\t\t\t\t\t  computed: {\n\t\t\t\t\t\t\t\t\t  // 使用对象展开运算符将 getters 混入 computed 对象中\n\t\t\t\t\t\t\t\t\t    ...mapGetters([\n\t\t\t\t\t\t\t\t\t      'countDouble',\n\t\t\t\t\t\t\t\t\t      'CountDoubleAndDouble',\n\t\t\t\t\t\t\t\t\t      //..\n\t\t\t\t\t\t\t\t\t    ])\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t"},{subtitle:"如果你想将一个 getter 属性另取一个名字，使用对象形式：",subcode:"mapGetters({\n\t\t\t\t\t  // 映射 this.double 为 store.getters.countDouble\n\t\t\t\t\t  double: 'countDouble'\n\t\t\t\t\t})\n\t\t\t\t\t\t\t\t"}]},{word:"Mutations",title:"提交mutation是更改Vuex中的store中的状态的唯一方法。",codes:[{subtitle:"更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数,提交载荷作为第二个参数。（提交荷载在大多数情况下应该是一个对象）,提交荷载也可以省略的。",code:"const store = new Vuex.Store({\n\t\t\t\t\t\t\t\t\t\t\t\t  state: {\n\t\t\t\t\t\t\t\t\t\t\t\t    count: 1\n\t\t\t\t\t\t\t\t\t\t\t\t  },\n\t\t\t\t\t\t\t\t\t\t\t\t  mutations: {\n\t\t\t\t\t\t\t\t\t\t\t\t    //无提交荷载\n\t\t\t\t\t\t\t\t\t\t\t\t    increment(state) {\n\t\t\t\t\t\t\t\t\t\t\t\t        state.count++\n\t\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t\t    //提交荷载\n\t\t\t\t\t\t\t\t\t\t\t\t    increment(state, obj) {\n\t\t\t\t\t\t\t\t\t\t\t\t      state.count += obj.n\n\t\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t})"},{subtitle:"你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：",code:"//无提交荷载\n\t\t\t\t\t\t\t\t\t\t\tstore.commit('increment')\n\t\t\t\t\t\t\t\t\t\t\t//提交荷载\n\t\t\t\t\t\t\t\t\t\t\tstore.commit('increment', {\n\t\t\t\t\t\t\t\t\t\t\t    n: 100\n\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t"},{subtitle:"在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：",code:"// ...\n\t\t\t\t\t\t\t\t\t\tstore.commit({\n\t\t\t\t\t\t\t\t\t\t  type: 'increment',\n\t\t\t\t\t\t\t\t\t\t  n: 10\n\t\t\t\t\t\t\t\t\t\t})"},{subtitle:"当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：",code:"mutations: {\n\t\t\t\t\t\t\t\t\t\t  increment (state, payload) {\n\t\t\t\t\t\t\t\t\t\t    state.count += payload.amount\n\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t}"},{subtitle:"使用常量替代 Mutation 事件类型--使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：",code:"// mutation-types.js\n\t\t\t\t\texport const SOME_MUTATION = 'SOME_MUTATION'\n\t\t\t\t\t// store.js\n\t\t\t\t\timport Vuex from 'vuex'\n\t\t\t\t\timport { SOME_MUTATION } from './mutation-types'\n\n\t\t\t\t\tconst store = new Vuex.Store({\n\t\t\t\t\t  state: { ... },\n\t\t\t\t\t  mutations: {\n\t\t\t\t\t    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n\t\t\t\t\t    [SOME_MUTATION] (state) {\n\t\t\t\t\t      // mutate state\n\t\t\t\t\t    }\n\t\t\t\t\t  }\n\t\t\t\t\t})\n\t\t\t\t"}],subWord:[{title:"在组件中提交 Mutation",subtitle:"你可以在组件中使用 this.$store.commit('xxx') 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。\n\n",subcode:"import { mapMutations } from 'vuex'\n\n\t\t\t\t\texport default {\n\t\t\t\t\t  // ...\n\t\t\t\t\t  methods: {\n\t\t\t\t\t    ...mapMutations([\n\t\t\t\t\t      'increment', // 将 'this.increment()' 映射为 'this.$store.commit('increment')'\n\n\t\t\t\t\t      // 'mapMutations' 也支持载荷：\n\t\t\t\t\t      'incrementBy' // 将 'this.incrementBy(amount)' 映射为 'this.$store.commit('incrementBy', amount)'\n\t\t\t\t\t    ]),\n\t\t\t\t\t    ...mapMutations({\n\t\t\t\t\t      add: 'increment' // 将 'this.add()' 映射为 'this.$store.commit('increment')'\n\t\t\t\t\t    })\n\t\t\t\t\t  }\n\t\t\t\t\t}"}]},{word:"Action",title:"Action 类似于 mutation，不同在于：",codes:[{subtitle:"Action 提交的是 mutation，而不是直接变更状态。\n\t\t\t\t\t\t\t\t\t\t\t\t\tAction 可以包含任意异步操作。让我们来注册一个简单的 action：",code:"const store = new Vuex.Store({\n\t\t\t\t\t\t\t\t\t\t\t\t\t  state: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t    count: 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t  },\n\t\t\t\t\t\t\t\t\t\t\t\t\t  mutations: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t    increment (state) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t      state.count++\n\t\t\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t\t\t  },\n\t\t\t\t\t\t\t\t\t\t\t\t\t  actions: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t    increment (context) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t      context.commit('increment')\n\t\t\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t\t"},{subtitle:"Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。"},{subtitle:"分发actions Action 通过 store.dispatch 方法触发：",code:"store.dispatch('increment')"}],subWord:[{title:"其他与mutations类似的地方",subtitle:"Actions 支持同样的载荷方式和对象方式进行分发：",subcode:"// 以载荷形式分发\n\t\t\t\t\t\t\t\t\t\tstore.dispatch('increment', {\n\t\t\t\t\t\t\t\t\t\t  n: 10\n\t\t\t\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\t\t\t\t// 以对象形式分发\n\t\t\t\t\t\t\t\t\t\tstore.dispatch({\n\t\t\t\t\t\t\t\t\t\t  type: 'increment',\n\t\t\t\t\t\t\t\t\t\t  n: 10\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t"},{subtitle:"来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：",subcode:"actions: {\n\t\t\t\t\t  checkout ({ commit, state }, products) {\n\t\t\t\t\t    // 把当前购物车的物品备份起来\n\t\t\t\t\t    const savedCartItems = [...state.cart.added]\n\t\t\t\t\t    // 发出结账请求，然后乐观地清空购物车\n\t\t\t\t\t    commit(types.CHECKOUT_REQUEST)\n\t\t\t\t\t    // 购物 API 接受一个成功回调和一个失败回调\n\t\t\t\t\t    shop.buyProducts(\n\t\t\t\t\t      products,\n\t\t\t\t\t      // 成功操作\n\t\t\t\t\t      () => commit(types.CHECKOUT_SUCCESS),\n\t\t\t\t\t      // 失败操作\n\t\t\t\t\t      () => commit(types.CHECKOUT_FAILURE, savedCartItems)\n\t\t\t\t\t    )\n\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t",supplement:"注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。"},{title:"在组件中分发 Action",subtitle:"你在组件中使用 this.$store.dispatch('xxx') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：",subcode:"import { mapActions } from 'vuex'\n\n\t\t\t\t\texport default {\n\t\t\t\t\t  // ...\n\t\t\t\t\t  methods: {\n\t\t\t\t\t    ...mapActions([\n\t\t\t\t\t      'increment', // 将 'this.increment()' 映射为 'this.$store.dispatch('increment')'\n\n\t\t\t\t\t      // 'mapActions' 也支持载荷：\n\t\t\t\t\t      'incrementBy' // 将 'this.incrementBy(amount)' 映射为 'this.$store.dispatch('incrementBy', amount)'\n\t\t\t\t\t    ]),\n\t\t\t\t\t    ...mapActions({\n\t\t\t\t\t      add: 'increment' // 将 'this.add()' 映射为 'this.$store.dispatch('increment')'\n\t\t\t\t\t    })\n\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t"},{title:"组合 Action",subtitle:"Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？\n          \t\t\t首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：",subcode:"actions: {\n\t\t\t\t\t\t\t\t\t  actionA ({ commit }) {\n\t\t\t\t\t\t\t\t\t    return new Promise((resolve, reject) => {\n\t\t\t\t\t\t\t\t\t      setTimeout(() => {\n\t\t\t\t\t\t\t\t\t        commit('someMutation')\n\t\t\t\t\t\t\t\t\t        resolve()\n\t\t\t\t\t\t\t\t\t      }, 1000)\n\t\t\t\t\t\t\t\t\t    })\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t}"},{subtitle:"现在你可以：",subcode:"store.dispatch('actionA').then(() => {\n\t\t\t\t\t\t\t\t\t\t\t  // ...\n\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t"},{subtitle:"在另外一个 action 中也可以：",subcode:"actions: {\n\t\t\t\t\t  // ...\n\t\t\t\t\t  actionB ({ dispatch, commit }) {\n\t\t\t\t\t    return dispatch('actionA').then(() => {\n\t\t\t\t\t      commit('someOtherMutation')\n\t\t\t\t\t    })\n\t\t\t\t\t  }\n\t\t\t\t\t}\t\t"},{subtitle:"最后，如果我们利用 async / await，我们可以如下组合 action：",subcode:"// 假设 getData() 和 getOtherData() 返回的是 Promise\n\n\t\t\t\t\tactions: {\n\t\t\t\t\t  async actionA ({ commit }) {\n\t\t\t\t\t    commit('gotData', await getData())\n\t\t\t\t\t  },\n\t\t\t\t\t  async actionB ({ dispatch, commit }) {\n\t\t\t\t\t    await dispatch('actionA') // 等待 actionA 完成\n\t\t\t\t\t    commit('gotOtherData', await getOtherData())\n\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t",supplement:"一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。"}]},{word:"Module",title:"由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。",codes:[{subtitle:"为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：",code:"const moduleA = {\n\t\t\t\t\t\t\t\t\t\t  state: { ... },\n\t\t\t\t\t\t\t\t\t\t  mutations: { ... },\n\t\t\t\t\t\t\t\t\t\t  actions: { ... },\n\t\t\t\t\t\t\t\t\t\t  getters: { ... }\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tconst moduleB = {\n\t\t\t\t\t\t\t\t\t\t  state: { ... },\n\t\t\t\t\t\t\t\t\t\t  mutations: { ... },\n\t\t\t\t\t\t\t\t\t\t  actions: { ... }\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tconst store = new Vuex.Store({\n\t\t\t\t\t\t\t\t\t\t  modules: {\n\t\t\t\t\t\t\t\t\t\t    a: moduleA,\n\t\t\t\t\t\t\t\t\t\t    b: moduleB\n\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\t\t\t\tstore.state.a // -> moduleA 的状态\n\t\t\t\t\t\t\t\t\t\tstore.state.b // -> moduleB 的状态"}],subWord:[{title:"模块的局部状态",subtitle:"对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。",subcode:"const moduleA = {\n\t\t\t\t\t  state: { count: 0 },\n\t\t\t\t\t  mutations: {\n\t\t\t\t\t    increment (state) {\n\t\t\t\t\t      // 这里的 'state' 对象是模块的局部状态\n\t\t\t\t\t      state.count++\n\t\t\t\t\t    }\n\t\t\t\t\t  },\n\n\t\t\t\t\t  getters: {\n\t\t\t\t\t    doubleCount (state) {\n\t\t\t\t\t      return state.count * 2\n\t\t\t\t\t    }\n\t\t\t\t\t  }\n\t\t\t\t\t}"},{subtitle:"同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：",subcode:"const moduleA = {\n\t\t\t\t\t\t\t\t\t  // ...\n\t\t\t\t\t\t\t\t\t  actions: {\n\t\t\t\t\t\t\t\t\t    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n\t\t\t\t\t\t\t\t\t      if ((state.count + rootState.count) % 2 === 1) {\n\t\t\t\t\t\t\t\t\t        commit('increment')\n\t\t\t\t\t\t\t\t\t      }\n\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t"},{subtitle:"对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：",subcode:"const moduleA = {\n\t\t\t\t\t\t\t\t  // ...\n\t\t\t\t\t\t\t\t  getters: {\n\t\t\t\t\t\t\t\t    sumWithRootCount (state, getters, rootState) {\n\t\t\t\t\t\t\t\t      return state.count + rootState.count\n\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t"}]}]}}},s,!1,null,null,null);e.default=a.exports},eu7k:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var s={render:function(){var t=this.$createElement;return(this._self._c||t)("div",[this._v("Signup")])},staticRenderFns:[]},a=n("VU/8")(null,s,!1,null,null,null);e.default=a.exports},gORT:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var s={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"hello"},[n("h1",[t._v(t._s(t.msg))]),t._v(" "),n("h2",[t._v("Essential Links")]),t._v(" "),t._m(0),t._v(" "),n("h2",[t._v("Ecosystem")]),t._v(" "),t._m(1)])},staticRenderFns:[function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ul",[n("li",[n("a",{attrs:{href:"https://vuejs.org",target:"_blank"}},[t._v("\n        Core Docs\n      ")])]),t._v(" "),n("li",[n("a",{attrs:{href:"https://forum.vuejs.org",target:"_blank"}},[t._v("\n        Forum\n      ")])]),t._v(" "),n("li",[n("a",{attrs:{href:"https://chat.vuejs.org",target:"_blank"}},[t._v("\n        Community Chat\n      ")])]),t._v(" "),n("li",[n("a",{attrs:{href:"https://twitter.com/vuejs",target:"_blank"}},[t._v("\n        Twitter\n      ")])]),t._v(" "),n("br"),t._v(" "),n("li",[n("a",{attrs:{href:"http://vuejs-templates.github.io/webpack/",target:"_blank"}},[t._v("\n        Docs for This Template\n      ")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("a",{attrs:{href:"http://router.vuejs.org/",target:"_blank"}},[this._v("\n        vue-router\n      ")])]),this._v(" "),e("li",[e("a",{attrs:{href:"http://vuex.vuejs.org/",target:"_blank"}},[this._v("\n        vuex\n      ")])]),this._v(" "),e("li",[e("a",{attrs:{href:"http://vue-loader.vuejs.org/",target:"_blank"}},[this._v("\n        vue-loader\n      ")])]),this._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/vuejs/awesome-vue",target:"_blank"}},[this._v("\n        awesome-vue\n      ")])])])}]};var a=n("VU/8")({name:"HelloWorld",data:function(){return{msg:"Welcome to Your Vue.js App"}}},s,!1,function(t){n("1uuo")},"data-v-d8ec41bc",null);e.default=a.exports},ixtv:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var s={render:function(){var t=this.$createElement;return(this._self._c||t)("div",[this._v("Signin")])},staticRenderFns:[]},a=n("VU/8")(null,s,!1,null,null,null);e.default=a.exports},kjei:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var s=n("BbIT"),a=n.n(s);for(var o in s)"default"!==o&&function(t){n.d(e,t,function(){return s[t]})}(o);var r=n("tncu"),i=n("VU/8")(a.a,r.a,!1,null,null,null);e.default=i.exports},tncu:function(t,e,n){"use strict";var s={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("v-container",[n("v-layout",{attrs:{row:"",wrap:""}},[n("v-flex",{staticClass:"text-xs-center",attrs:{xs12:""}},[n("v-btn",{staticClass:"pink",attrs:{large:"",dark:"",to:{name:"MaxVuetifyHome"}}},[t._v("Home")]),t._v(" "),n("v-btn",{staticClass:"pink",attrs:{large:"",dark:"",to:{name:"Meetups"}}},[t._v("VIEW MEETUPS")]),t._v(" "),n("v-btn",{staticClass:"pink",attrs:{large:"",dark:"",to:{name:"CreateMeetup"}}},[t._v("ORGANIZE MEETUPS")]),t._v(" "),n("v-btn",{staticClass:"pink",attrs:{large:"",dark:"",to:{name:"Profile"}}},[t._v("PROFILE")])],1)],1),t._v(" "),n("v-layout",{attrs:{row:"",wrap:""}},[n("v-flex",{attrs:{xs12:""}},[n("router-view")],1)],1)],1)},staticRenderFns:[]};e.a=s},ty6V:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var s={render:function(){var t=this.$createElement;return(this._self._c||t)("div",[this._v("Profile")])},staticRenderFns:[]},a=n("VU/8")(null,s,!1,null,null,null);e.default=a.exports},wqTG:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var s={render:function(){var t=this.$createElement;return(this._self._c||t)("div",[this._v("home")])},staticRenderFns:[]},a=n("VU/8")(null,s,!1,null,null,null);e.default=a.exports},zDvx:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var s={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("v-layout",{attrs:{row:"",wrap:""}},[n("v-flex",{attrs:{xs12:""}},[n("v-card",[n("v-toolbar",{attrs:{color:"pink",dark:""}},[n("v-toolbar-title",[t._v("阿里前端面试总结")]),t._v(" "),n("v-spacer")],1)],1)],1),t._v(" "),t._l(t.codeDatas,function(e,s){return n("v-flex",{key:s,attrs:{xs12:"","pa-1":""}},[n("v-card",{staticClass:"white--text",attrs:{color:"blue-grey darken-2"}},[n("v-container",{attrs:{fluid:"","grid-list-lg":""}},[n("v-layout",{attrs:{row:""}},[n("v-flex",[n("div",[n("div",{staticClass:"headline"},[t._v(t._s(e.title))]),t._v(" "),n("div",[t._v("\t"+t._s(e.subtitle))]),t._v(" "),e.code?n("div",[n("codemirror",{attrs:{value:e.code}})],1):t._e(),t._v(" "),e.characteristic?n("div",[e.characteristic.advantage?n("v-list",{attrs:{"two-line":"",subheader:""}},[n("v-subheader",{staticClass:"teal--text"},[t._v("优点")]),t._v(" "),n("v-card",[n("v-card-text",{staticClass:"pl-5"},t._l(e.characteristic.advantage,function(e,s){return n("p",{staticClass:"text-sm-left"},[t._v(t._s(e))])}))],1)],1):t._e(),t._v(" "),n("v-divider"),t._v(" "),e.characteristic.defect?n("v-list",{attrs:{"two-line":"",subheader:""}},[n("v-subheader",{staticClass:"red--text"},[t._v("缺点")]),t._v(" "),n("v-card-text",{staticClass:"pl-5"},t._l(e.characteristic.defect,function(e,s){return n("p",{staticClass:"text-sm-left"},[t._v(t._s(e))])}))],1):t._e()],1):t._e()])])],1)],1)],1)],1)}),t._v(" "),n("v-flex",{attrs:{xs12:"","pa-1":""}},[n("v-card",{staticClass:"white--text",attrs:{color:"purple"}},[n("v-container",{attrs:{fluid:"","grid-list-lg":""}},[n("v-layout",{attrs:{row:""}},[n("v-flex",{attrs:{xs7:""}},[n("div",[n("div",{staticClass:"headline"},[t._v("2")]),t._v(" "),n("div",[t._v("2")])])]),t._v(" "),n("v-flex",{attrs:{xs5:""}},[n("v-card-media",{attrs:{src:"/static/doc-images/cards/halcyon.png",height:"125px",contain:""}})],1)],1)],1)],1)],1)],2)},staticRenderFns:[]};var a=n("VU/8")({data:function(){return{selected:[2],items:[{action:"15 min",headline:"Brunch this weekend?",title:"Ali Connors",subtitle:"I'll be in your neighborhood doing errands this weekend. Do you want to hang out?"}],codeDatas:[{title:"1.有一个长度未知的数组a，如果它的长度为0就把数字1添加到数组里面，否则按照先进先出的队列规则让第一个元素出队。",subtitle:"分析：这道题主要是考核了数组的队列方法和栈方法。我们可以使用三目运算符（： ？）来减少字数。代码如下：",code:"a.length === 0 ? a.push(1) : a.shift();"},{title:"2.下面代码会输出什么：",subtitle:"分析：这道题考了与函数有关的的两个非常重要的概念：自执行函数和闭包。",code:"var test = (function(a) {    \n\t\t\t\t\t\t\t\t\t\tthis.a = a;    \n\t\t\t\t\t\t\t\t\t\treturn function(b) {        \n\t\t\t\t\t\t\t\t\t\treturn this.a + b;\n\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t} (function(a, b) {    \n\t\t\t\t\t\t\t\t\t\treturn a;\n\t\t\t\t\t\t\t\t\t\t}(1, 2))); \n\n\t\t\t\t\t\t\t\t\t\tconsole.log(test(4)); "},{title:"3.请把<ul><li>第1行</li><li\t>第2行</li\t>...</ul>（ul之间有10个li元素）插入body里面，注意：需要考虑到性能问题。",subtitle:"分析：这题主要考察了dom操作。插入节点操作的可以使用insertBefore和appendChild方法，随便用一个都行。但是，题目要求要考虑性能问题，这才是关键，因为，JavaScript操作dom的开销是很大的！提高性能就要减少dom操作。因此，我当时使用了下面的方法，只操作一次dom就够的了：",code:'var lis = "",\n\t\t\t\t\t\t\tul = document.createElement("ul");\n\t\t\t\t\t\t\t//把li以字符串形式生成\n\t\t\t\t\t\t\tfor(var i = 1; i <= 10; i++) {\n\t\t\t\t\t\t\t    lis += "<li>第" + i + "行</li>";\n\t\t\t\t\t\t\t}// 最后通过innerHTML插入ul里面\n\t\t\t\t\t\t\tul.innerHTML = lis;\n\t\t\t\t\t\t\t//这里才操作dom，把ul插入到body\n\t\t\t\t\t\t\tdocument.body.appendChild(ul); '},{title:"4.不使用loop循环，创建一个长度为100的数组，并且每个元素的值等于它的下标。",subtitle:"分析：当时看到题目要求不使用loop循环时，“聪明过头”的我马上就想到了使用间歇性定时器setInterval，代码如下：",code:"var arr = [],\n\t\t  \t\t\ti = 0;\n\t\t  \t\tvar interval = setInterval(()=>{\n\t\t  \t\t\ti < 100 ? arr.push(i++) : clearInterval(interval);\n\t\t  \t\t}, 0);"},{title:"另一种做法",subtitle:"分析：  先创建一个新数组，然后通过join方法把它转化为字符串，然后再通过split方法把字符串转化为数组，这时候，它就拥有100个值为空的元素了，然后再通过map函数改变这些元素值即可。",code:"\n\t\t\tvar arr = Array(100).join(',').split(',').map((item, index)=>index)\n\t\t\tconsole.log(arr)\n\t\t\t"},{title:"5.实现对数组进行乱序",subtitle:"分析： 使用sort对数组进行排序，因为是乱序，还需要用到Math.random()产生随机数，用来打乱排序规律！代码如下：",code:"\n\t\t\tvar arr = [1,4,2,100,99,5,6,7,120,28,88],\n\t\t\t\tflag = 1;\n\t\t\tarr.sort((a, b)=>{\n\t\t\t\tflag = (Math.random() > 0.5) ? 1 : -1;\n\t\t\t\treturn (a - b) * flag;\n\t\t\t})\n\t\t\tconsole.log(arr)\n\t\t"},{title:"6.有一个长度为100的数组，或者随机生成一个1-100的数组，请以优雅的方式求出该数组的前10个元素之和",subtitle:'分析：其实，对于数组求和有很多种方法。但是，这题有两个限制条件：优雅的方式、前10个元素。对于“前10个元素”这个限制条件可以使用Array.prototype.slice()方法来截取，对于"优雅的方式"，我的理解是应该尽可能使用数组自带的方法，最好可以使用高阶函数！所以我觉得应该是Array.prototype.reduce()方法。代码如下：',code:"let sum = 0;\n\t  \t\tsum = Array(100).join(',').split(',').map((item, index)=>{\n\t  \t\t\tindex++;\n\t  \t\t\treturn index;\n\t  \t\t}).reduce((prev, cur)=>prev+cur)"},{title:"7.JavaScript实现继承的常用方法有哪些？你推荐的是哪一种？",subtitle:"既然要实现继承，那么首先我们得有一个父类，代码如下："},{title:"1、原型链继承",subtitle:"核心： 将父类的实例作为子类的原型",code:"\n\t\t\tfunction Animal(name) {\n  \t\t\t// 属性\n  \t\t\tthis.name = name || 'Animal'\n\n  \t\t\t//实例方法\n  \t\t\tthis.sleep = () => this.name + 'is sleeping now'\n\t  \t\t}\n\n\t  \t\tAnimal.prototype.eat = food => this.name + 'is eating ' + food + ' now!'\n\n\t  \t\tfunction Cat() {\n\t  \t\t}\n\t  \t\tCat.prototype = new Animal()\n\t  \t\tCat.prototype.name = 'cat'\n\n\t  \t\tlet cat = new Cat()\n\t  \t\tconsole.log(cat.name) // cat\n\t  \t\tconsole.log(cat.eat('fish')) // is eating fish now!\n\t  \t\tcat.sleep()  // catis sleeping now\n\t  \t\tconsole.log(cat instanceof Animal); //true \n\t\t\tconsole.log(cat instanceof Cat); //true\n\t\t",characteristic:{advantage:["非常纯粹的继承关系，实例是子类的实例，也是父类的实例","父类新增原型方法/原型属性，子类都能访问到","简单，易于实现"],defect:["要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中","无法实现多继承","来自原型对象的引用属性是所有实例共享的","创建子类实例时，无法向父类构造函数传参"]}},{title:"2、构造继承",subtitle:"核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）",code:"\n\t\t\tfunction Animal(name) {\n\t  \t\t\tthis.name = name || 'Animal'\n\t  \t\t\tthis.sleep = () => this.name + ' sleeping now'\n\t  \t\t}\n\n\t  \t\tfunction Cat(name) {\n\t  \t\t\tAnimal.call(this)\n\t  \t\t\tthis.name = name || 'Bom'\n\t  \t\t}\n\t  \t\tlet cat = new Cat()\n\t  \t\tconsole.log(cat) // cat\n\t  \t\tcat.sleep()\t// Bom is sleeping now\n\t  \t\tconsole.log(cat instanceof Animal); // false\n\t\t\tconsole.log(cat instanceof Cat); // true\n\t\t",characteristic:{advantage:["解决了1中，子类实例共享父类引用属性的问题","创建子类实例时，可以向父类传递参数","可以实现多继承（call多个父类对象）"],defect:["实例并不是父类的实例，只是子类的实例","只能继承父类的实例属性和方法，不能继承原型属性/方法","无法实现函数复用，每个子类都有父类实例函数的副本，影响性能"]}},{title:"3、实例继承",subtitle:"核心：为父类实例添加新特性，作为子类实例返回",code:"\n\t\t\tfunction Animal(name) {\n  \t\t\tthis.name = name || 'Animal'\n  \t\t\tthis.sleep = () => this.name + ' is sleeping now'\n\t  \t\t}\n\t  \t\tfunction Cat(name) {\n\t  \t\t\tlet ins = new Animal()\n\t  \t\t\t\tins.name = name || 'Gom'\n\t  \t\t\t\treturn ins\n\t  \t\t}\n\n\t  \t\tlet cat = new Cat()\n\t  \t\tconsole.log(cat.name)\t// Gom\n\t  \t\tconsole.log(cat.sleep()); // Gom is sleeping now\n\t\t\tconsole.log(cat instanceof Animal); // true\n\t\t\tconsole.log(cat instanceof Cat); // false\n\t\t",characteristic:{advantage:["不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果"],defect:["实例是父类的实例，不是子类的实例","不支持多继承"]}},{title:"4、拷贝继承",subtitle:"",code:"\n\t\t\tfunction Animal(name) {\n\t  \t\t\tthis.name = name || 'Animal'\n\t  \t\t\tthis.sleep = () => this.name + ' is sleeping now'\n\t  \t\t}\n\t  \t\tfunction Cat(name) {\n\t  \t\t\tlet cat = new Animal()\n\t  \t\t\tfor(let c in cat){\n\t  \t\t\t\tCat.prototype[c] = cat[c]\n\t  \t\t\t}\n\t  \t\t\tCat.prototype.name = name || 'Fom'\n\t  \t\t}\n\t  \t\tlet cat = new Cat()\n\t  \t\tconsole.log(cat.name) // Fom\n\t  \t\tconsole.log(cat.sleep())\n\t  \t\tconsole.log(cat instanceof Animal); // false\n\t\t\tconsole.log(cat instanceof Cat); // true",characteristic:{advantage:["支持多继承"],defect:["效率较低，内存占用高（因为要拷贝父类的属性）","无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）"]}},{title:"5、组合继承",subtitle:"核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用",code:"\n\t\t\tfunction Animal(name) {\n\t  \t\t\tthis.name = name || 'Animal'\n\t  \t\t\tthis.sleep = () => this.name + ' is sleeping now'\n\t  \t\t}\n\t  \t\tfunction Cat(name) {\n\t  \t\t\tAnimal.call(this)\n\t  \t\t\tthis.name = name || 'Hom'\n\t  \t\t}\n\t  \t\tCat.prototype = new Animal\n\t  \t\tlet cat = new Cat()\n\t  \t\tconsole.log(cat.name) // Hom\n\t  \t\tconsole.log(cat.sleep()) // Hom is sleeping now\n\t  \t\tconsole.log(cat instanceof Animal); // false\n\t\t\tconsole.log(cat instanceof Cat); // true",characteristic:{advantage:["弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法","既是子类的实例，也是父类的实例","不存在引用属性共享问题","可传参","函数可复用"],defect:["调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）"]}},{title:"6、寄生组合继承",subtitle:"核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点",code:"\n\t\t\tfunction Animal(name) {\n\t  \t\t\tthis.name = name || 'Animal'\n\t  \t\t\tthis.sleep = () => this.name + ' is sleeping now'\n\t  \t\t}\n\t  \t\tfunction Cat(name) {\n\t\t\t\tAnimal.call(this)\n\t  \t\t\tthis.name = name || 'Pom'\n\t  \t\t}\n\t  \t\t(()=>{\n\t  \t\t\tfunction Super() {}\n\t  \t\t\tSuper.prototype = Animal.prototype\n\t  \t\t\t Cat.prototype = new Super()\t\n\t  \t\t})()\n\t  \t\tlet cat = new Cat()\n\t  \t\tconsole.log(cat.name) // Pom\n\t  \t\tconsole.log(cat.sleep()) // Pom is sleeping now\n\t  \t\tconsole.log(cat instanceof Animal); // false\n\t\t\tconsole.log(cat instanceof Cat); // true\n\t\t\t",characteristic:{advantage:["堪称完美"],defect:["实现较为复杂"]}},{title:"8.在项目开发完成之后，根据雅虎性能优化规则，需要对html，JS，CSS，图片需要做出怎样的处理？是否可以借助构建工具实现自动化？",subtitle:"提示：从减少http请求、减少带宽、提高加载速度等方面进行答题即可。",characteristic:{advantage:["1. 尽可能的减少 HTTP 的请求数 [content]","2. 使用 CDN（Content Delivery Network） [server]","3. 添加 Expires 头(或者 Cache-control ) [server]","4. Gzip 组件 [server]","5. 将 CSS 样式放在页面的上方 [css]","6. 将脚本移动到底部（包括内联的） [javascript]","7. 避免使用 CSS 中的 Expressions [css]","8. 将 JavaScript 和 CSS 独立成外部文件 [javascript] [css]","9. 减少 DNS 查询 [content]","10. 压缩 JavaScript 和 CSS (包括内联的) [javascript] [css]","11. 避免重定向 [server]","12. 移除重复的脚本 [javascript]","13. 配置实体标签（ETags） [css]","14. 使 AJAX 缓存"]}}]}},methods:{toggle:function(t){var e=this.selected.indexOf(t);e>-1?this.selected.splice(e,1):this.selected.push(t)}}},s,!1,function(t){n("bsW1")},null,null);e.default=a.exports}});
//# sourceMappingURL=0.fd2fb34a61b688062d39.js.map